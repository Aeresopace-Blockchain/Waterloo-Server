"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
const constants_1 = require("./constants");
const jsonld_context_parser_1 = require("jsonld-context-parser");
const poseidon_1 = require("./poseidon");
const utils_1 = require("./utils");
const options_1 = require("./options");
class Path {
    constructor(parts = [], hasher = poseidon_1.DEFAULT_HASHER) {
        this.parts = parts;
        this.hasher = hasher;
    }
    reverse() {
        return this.parts.reverse();
    }
    append(p) {
        this.parts = [...this.parts, ...p];
    }
    prepend(p) {
        this.parts = [...p, ...this.parts];
    }
    async mtEntry() {
        const h = this.hasher ?? poseidon_1.DEFAULT_HASHER;
        const keyParts = new Array(this.parts.length).fill(BigInt(0));
        for (let i = 0; i < this.parts.length; i += 1) {
            const p = this.parts[i];
            if (typeof p === 'string') {
                const b = utils_1.byteEncoder.encode(p);
                keyParts[i] = await h.hashBytes(b);
            }
            else if (typeof p === 'number') {
                keyParts[i] = BigInt(p);
            }
            else {
                throw new Error(`error: unexpected type ${typeof p}`);
            }
        }
        return h.hash(keyParts);
    }
    async pathFromContext(docStr, path, opts) {
        const doc = JSON.parse(docStr);
        const context = doc['@context'];
        if (!context) {
            throw constants_1.MerklizationConstants.ERRORS.CONTEXT_NOT_DEFINED;
        }
        const docLoader = documentLoaderAdapter((0, options_1.getDocumentLoader)(opts));
        const ctxParser = new jsonld_context_parser_1.ContextParser({ documentLoader: docLoader });
        let parsedCtx = await ctxParser.parse(doc['@context']);
        const parts = path.split('.');
        for (const i in parts) {
            const p = parts[i];
            if (constants_1.MerklizationConstants.DIGITS_ONLY_REGEX.test(p)) {
                this.parts.push(parseInt(p));
            }
            else {
                if (!parsedCtx) {
                    throw constants_1.MerklizationConstants.ERRORS.PARSED_CONTEXT_IS_NULL;
                }
                const m = parsedCtx.getContextRaw()[p];
                if (typeof m !== 'object') {
                    throw constants_1.MerklizationConstants.ERRORS.TERM_IS_NOT_DEFINED;
                }
                const id = m['@id'];
                if (!id) {
                    throw constants_1.MerklizationConstants.ERRORS.NO_ID_ATTR;
                }
                const nextCtx = m['@context'];
                if (nextCtx) {
                    parsedCtx = await ctxParser.parse(nextCtx);
                }
                this.parts.push(id);
            }
        }
    }
    async typeFromContext(ctxStr, path, opts) {
        const ctxObj = JSON.parse(ctxStr);
        const docLoader = documentLoaderAdapter((0, options_1.getDocumentLoader)(opts));
        const ctxParser = new jsonld_context_parser_1.ContextParser({ documentLoader: docLoader });
        let parsedCtx = await ctxParser.parse(ctxObj['@context']);
        const parts = path.split('.');
        for (const i in parts) {
            const p = parts[i];
            if (!parsedCtx) {
                throw constants_1.MerklizationConstants.ERRORS.PARSED_CONTEXT_IS_NULL;
            }
            const m = parsedCtx.getContextRaw()[p];
            if (typeof m !== 'object') {
                throw constants_1.MerklizationConstants.ERRORS.TERM_IS_NOT_DEFINED;
            }
            const id = m['@id'];
            if (!id) {
                throw constants_1.MerklizationConstants.ERRORS.NO_ID_ATTR;
            }
            const nextCtx = m['@context'];
            if (nextCtx) {
                parsedCtx = await ctxParser.parse(nextCtx);
            }
            this.parts.push(id);
        }
        return Path.getTypeMapping(parsedCtx, parts[parts.length - 1]);
    }
    static getTypeMapping(ctx, prop) {
        let rval = '';
        const defaultT = ctx.getContextRaw()['@type'];
        if (defaultT) {
            rval = defaultT;
        }
        const propDef = ctx.getContextRaw()[prop];
        if (propDef && propDef['@type']) {
            rval = propDef['@type'];
        }
        return rval;
    }
    static async pathFromDocument(ldCTX, doc, pathParts, acceptArray, opts) {
        if (pathParts.length === 0) {
            return [];
        }
        const term = pathParts[0];
        const newPathParts = pathParts.slice(1);
        const docLoader = documentLoaderAdapter((0, options_1.getDocumentLoader)(opts));
        const ctxParser = new jsonld_context_parser_1.ContextParser({ documentLoader: docLoader });
        if (constants_1.MerklizationConstants.DIGITS_ONLY_REGEX.test(term)) {
            const num = parseInt(term);
            const moreParts = await Path.pathFromDocument(ldCTX, doc, newPathParts, true, opts);
            return [num, ...moreParts];
        }
        if (typeof doc !== 'object') {
            throw new Error(`error: expected type object got ${typeof doc}`);
        }
        let docObjMap = {};
        if (Array.isArray(doc)) {
            if (!doc.length) {
                throw new Error("errror: can't generate path on zero-sized array");
            }
            if (!acceptArray) {
                throw constants_1.MerklizationConstants.ERRORS.UNEXPECTED_ARR_ELEMENT;
            }
            return Path.pathFromDocument(ldCTX, doc[0], pathParts, false, opts);
        }
        else {
            docObjMap = doc;
        }
        const ctxData = docObjMap['@context'];
        if (ctxData) {
            if (ldCTX) {
                ldCTX = await ctxParser.parse(ctxData, { parentContext: ldCTX.getContextRaw() });
            }
            else {
                ldCTX = await ctxParser.parse(ctxData);
            }
        }
        const elemKeys = (0, utils_1.sortArr)(Object.keys(docObjMap));
        const typedScopedCtx = ldCTX;
        for (const k in elemKeys) {
            const key = elemKeys[k];
            const expandTerm = ldCTX.expandTerm(key, true);
            if (!(expandTerm === 'type' || expandTerm === '@type')) {
                continue;
            }
            let types = [];
            if (Array.isArray(docObjMap[key])) {
                docObjMap[key].forEach((e) => {
                    if (typeof e !== 'string') {
                        throw new Error(`error: @type value must be an array of strings: ${typeof e}`);
                    }
                    types.push(e);
                    types = (0, utils_1.sortArr)(types);
                });
            }
            else if (typeof docObjMap[key] === 'string') {
                types.push(docObjMap[key]);
            }
            else {
                throw new Error(`error: unexpected @type fied type: ${typeof docObjMap[key]}`);
            }
            for (const tt of types) {
                const td = typedScopedCtx.getContextRaw()[tt];
                if (typeof td === 'object') {
                    if (td) {
                        const ctxObj = td['@context'];
                        if (ctxObj) {
                            ldCTX = await ctxParser.parse(ctxObj, { parentContext: ldCTX.getContextRaw() });
                        }
                    }
                }
            }
            break;
        }
        const m = await ldCTX.getContextRaw()[term];
        const id = m['@id'];
        if (!id) {
            throw constants_1.MerklizationConstants.ERRORS.NO_ID_ATTR;
        }
        if (typeof id !== 'string') {
            throw new Error(`error: @id attr is not of type stirng: ${typeof id}`);
        }
        const moreParts = await Path.pathFromDocument(ldCTX, docObjMap[term], newPathParts, true, opts);
        return [id, ...moreParts];
    }
    static async newPathFromCtx(docStr, path, opts) {
        const p = new Path([], (0, options_1.getHasher)(opts));
        await p.pathFromContext(docStr, path, opts);
        return p;
    }
    static async fromDocument(ldCTX, docStr, path, opts) {
        const doc = JSON.parse(docStr);
        const pathParts = path.split('.');
        if (pathParts.length === 0) {
            throw constants_1.MerklizationConstants.ERRORS.FIELD_PATH_IS_EMPTY;
        }
        const p = await Path.pathFromDocument(ldCTX, doc, pathParts, false, opts);
        return new Path(p, (0, options_1.getHasher)(opts));
    }
    static async newTypeFromContext(contextStr, path, opts) {
        const p = new Path([], (0, options_1.getHasher)(opts));
        return await p.typeFromContext(contextStr, path, opts);
    }
    static async getTypeIDFromContext(ctxStr, typeName, opts) {
        const ctxObj = JSON.parse(ctxStr);
        const documentLoader = documentLoaderAdapter((0, options_1.getDocumentLoader)(opts));
        const ctxParser = new jsonld_context_parser_1.ContextParser({ documentLoader });
        const parsedCtx = await ctxParser.parse(ctxObj['@context']);
        const typeDef = parsedCtx.getContextRaw()[typeName];
        if (!typeDef) {
            throw new Error(`looks like ${typeName} is not a type`);
        }
        const typeID = typeDef['@id'];
        if (!typeID) {
            throw new Error(`@id attribute is not found for type ${typeName}`);
        }
        // const typeIDStr = typeID.(string)
        if (typeof typeID !== 'string') {
            throw new Error(`@id attribute is not a string for type ${typeName}`);
        }
        return typeID;
    }
}
exports.Path = Path;
_a = Path;
Path.newPath = (parts) => {
    const p = new Path();
    p.append(parts);
    return p;
};
Path.getContextPathKey = async (docStr, ctxTyp, fieldPath) => {
    if (ctxTyp === '') {
        throw constants_1.MerklizationConstants.ERRORS.CTX_TYP_IS_EMPTY;
    }
    if (fieldPath === '') {
        throw constants_1.MerklizationConstants.ERRORS.FIELD_PATH_IS_EMPTY;
    }
    const fullPath = await Path.newPathFromCtx(docStr, `${ctxTyp}.${fieldPath}`);
    const typePath = await Path.newPathFromCtx(docStr, ctxTyp);
    return new Path(fullPath.parts.slice(typePath.parts.length));
};
function documentLoaderAdapter(docLoader) {
    return {
        async load(url) {
            const doc = await docLoader(url);
            return doc.document;
        }
    };
}
//# sourceMappingURL=path.js.map